///////////////////////////////////////////////////////////////////////////////
version="$Id: frontalsurf.lib  2013-12-03 $";
category="Singularity Theory, Commutative Algebra";
info="
LIBRARY:	frontals.lib			Compute geometric invariants of a corank 1
									frontal surface

AUTHORS:	C. Munoz-Cabello,		chmuca@alumni.uv.es
  
PROCEDURES:
	invariants(p, q);				compute geometric frontal invariants
 
AUXILIARY PROCEDURES:
	baseringlocal();				checks if basering is local (ds)
	dp_scheme(p,q,y);				double point scheme of a frontal surface
	ordering(p, q);					sets a corank 1 frontal in pre-normal form
 ";

	// Required libraries
	LIB "classify.lib";
//	LIB "presmatrix.lib";		// presmatrix
	LIB "ring.lib";				// ord_test

//-----------------------------------------------------------------------------
proc invariants(poly @p_aux, poly @q_aux)
/*"USAGE:	invariants(p, q);		p,q=poly
*COMPUTE:	
*RETURN:   	
*REMARK:  	This version of invariants is only beta. Please send bugs and
*         	comments to: \"\" <chmuca@alumni.uv.es> @*
*          	Known to work on Singular version 4.2.0. 
*NOTE:		The proc creates several global objects with names all starting
*			with @, hence there should be no name conflicts.
*EXAMPLE:	example invariants; shows an example"
*/
{
	baseringlocal();
	option(noredefine);		// hide messages such as "redefining"

		/* sets the frontal so that p_y divides q_y
		 * sigma[1] is the x variable
		 * sigma[2] is the y variable
		 */
	list @sigma = ordering(@p_aux, @q_aux);
	if (@sigma[3] < @sigma[4])
	{
		poly @p = @p_aux;
		poly @q = @q_aux;
	}
	else
	{
		poly @p = @q_aux;
		poly @q = @p_aux;
	}

		// computations related to the double point scheme
	dp_scheme(@p, @q, @sigma[2]);
}

//-----------------------------------------------------------------------------
static proc baseringlocal()
{
	option(noredefine);			// hide messages such as "redefining"
	ring @ring=basering;

	int @local=ord_test(@ring);
	if (@local!=-1)
	{
		ERROR("// No local order ring! Get generators using local order
		(ds)");
	}
}

//-----------------------------------------------------------------------------
static proc ordering(poly @p, poly @q)
// Static procedures cannot be called from the global env
{
		// py | qy -> change nothing
	if (reduce(diff(@q, var(2)), diff(@p, var(2))) == 0)
		{return(1, 2, 3, 4);}

		// px | qx -> swap (x, y)
	if (reduce(diff(@q, var(1)), diff(@p, var(1))) == 0)
		{return(2, 1, 3, 4);}

		// qy | py -> swap (p, q)
	if (reduce(diff(@p, var(2)), diff(@q, var(2))) == 0)
		{return(1, 2, 4, 3);}

		// qx | px -> swap (x, y) and (p, q)
	if (reduce(diff(@p, var(1)), diff(@q, var(1))) == 0)
		{return(2, 1, 4, 3);}
	
	ERROR("// Not a frontal mapping! Please check "+string(@p)+" and "
	+string(@q));
}

//-----------------------------------------------------------------------------
static proc dp_scheme(poly @p, poly @q, int @y)
{
		// add an auxiliar variable for divided differences
	ring @src = basering;
	ring @auxring = 0, @z, ds;
	def @extring = @src + @auxring;
	setring @extring;

		// import @p and @q to the extended ring
	poly @p = imap(@src, @p);
	poly @q = imap(@src, @q);

		// compute the double point scheme via divided differences
	poly @P = (@p - subst(@p, var(@y), @z)) / (var(@y) - @z);
	poly @Q = (@q - subst(@q, var(@y), @z)) / (var(@y) - @z);

		// find its branches
	poly @py = diff(@p, var(@y));
	poly @tau = resultant(@P, @Q, @z) / @py^2;
	
		// compute formulas () from [1]
	poly @alpha = reduce(@P, @py) / (var(@y) - @z);
	poly @beta = reduce(@Q, @py) / (var(@y) - @z);
	ideal @A = @py, @alpha, @beta;
	int @vdimA = vdim(std(@A));

	setring @src;
	poly @cuspedge = imap(@extring, @py);
	ideal @B = @cuspedge, diff(@cuspedge, var(@y));
	
	poly @dpoints = imap(@extring, @tau);
	ideal @C = @cuspedge, @dpoints;

	print("// Cuspidal edges:");
	print("//	Equation: " + string(@cuspedge) + "= 0");
	print("// 	Milnor number: " + string(milnor(@cuspedge)));
	export(@cuspedge);
	
	print("//");
	print("// Strict double points:");
	print("//	Equation: " + string(@dpoints) + "= 0");
	print("// 	Milnor number: " + string(milnor(@dpoints)));
	export(@dpoints);

	print("//");	
	print("// Access these functions by typing @cuspedge and @dpoints");
	print("// (address sign included!)");
		
	return(@vdimA,
			vdim(std(@B)),
			vdim(std(@C)),
			);
}

///////////////////////////////////////////////////////////////////////////////
